var documenterSearchIndex = {"docs":
[{"location":"functions/#Private-functions","page":"Private functions","title":"Private functions","text":"","category":"section"},{"location":"functions/","page":"Private functions","title":"Private functions","text":"Pages = [\"functions.md\"] ","category":"page"},{"location":"functions/","page":"Private functions","title":"Private functions","text":"Modules = [STLCutters]\nPublic = false\nOrder   = [:function]","category":"page"},{"location":"functions/#Base.eps-Tuple{Type{<:AbstractFloat}, Gridap.Geometry.Grid}","page":"Private functions","title":"Base.eps","text":"Base.eps(T::Type{<:AbstractFloat},grid::Grid)\n\nReturn the machine roundoff error of a Grid. It returns eps() of the   maximum length of the bounding box of the Grid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.split","page":"Private functions","title":"Base.split","text":"split(p::Polyhedron,plane;kwargs...)\n\nIt splits a polyhedron by a plane into two polyhedra.\n\nIt returns a tuple of Union{Polyhedron,Nothing}.   If one side is empty, it returns nothing for that side.\n\nOptional keyword arguments\n\nside::Symbol=:both: It returns :both sides, the :left side, or the :right side\ninvert::Bool=false: It inverts the plane\n\n\n\n\n\n","category":"function"},{"location":"functions/#Gridap.ReferenceFEs.get_polytope-Tuple{STLCutters.Face}","page":"Private functions","title":"Gridap.ReferenceFEs.get_polytope","text":"get_polytope(f::Face)\n\nIt returns the Gridap Polytope that defines the Face f.\n\n\n\n\n\n","category":"method"},{"location":"functions/#GridapEmbedded.Interfaces.cut-Tuple{STLCutter, Gridap.Geometry.DiscreteModel, STLGeometry}","page":"Private functions","title":"GridapEmbedded.Interfaces.cut","text":"cut([cutter::STLCutter,]model::DiscreteModel,geo::STLGeometry)\n\nMain interface of GridapEmbedded. It intersect each cell in model with the geometry geo. It returns an embedded discretization.\n\nUsage\n\nThe basic usage is to call cut with a model and a geometry.\n\ncutgeo = cut(model,geo)\n\nWe can also set custom keyword arguments, see subtriangulate.\n\ncutter = STLCutter(;tolfactor=1e3)\ncutgeo = cut(cutter,model,geo)\n\nThen we can extract the domain and the boundary of the embedded discretization.\n\nΩ = Triangulation(cutgeo)\nΓ = EmbeddedBoundary(cutgeo)\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters._group_vertices-Union{Tuple{Gridap.Geometry.Grid{Dc, D}}, Tuple{D}, Tuple{Dc}} where {Dc, D}","page":"Private functions","title":"STLCutters._group_vertices","text":"_group_vertices(grid::Grid;atol)\n\nGroup a list of vertices which are closer than atol.   It returns a vector of vectors with the indices of grouped vertices.\n\nTo perform the classification, this function utilizes an auxiliar   CartesianGrid of size h>atol.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters._map_equal_vertices_from_cloud-Tuple{Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters._map_equal_vertices_from_cloud","text":"_map_equal_vertices_from_cloud(stl::DiscreteModel;atol])\n\nFind vertices closer than a tolerance atol. It returns a vector from each   vector to the index of a vertex which is closer than atol.\n\nIn order to find the vertices without quadratic complexity, it requires   to group the vertices in a grid  with an arbitrary tolerance > atol.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.bisector_plane-Tuple{STLCutters.Face{1, 3}, STLCutters.AbstractPlane, STLCutters.AbstractPlane}","page":"Private functions","title":"STLCutters.bisector_plane","text":"bisector_plane(e::Face,Π1::AbstractPlane,Π2::AbstractPlane)\n\nIt returns the bisector plane between two planes. The bisector contains the   edge e.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.bisector_plane-Tuple{STLCutters.STLTopology, Integer, Integer, AbstractArray}","page":"Private functions","title":"STLCutters.bisector_plane","text":"bisector_plane(stl::STL,d::Integer,dface::Integer,Πf::AbstractArray)\n\nCompute the bisector plane of two facets in a STL model. The two facets   must be connected by a STL edge (dface).\n\nArguments\n\nstl::STL: The surface model.\nd::Integer: The dimension of the edge (0 for 2D, 1 for 3D).\ndface::Integer: The index of the edge.\nΠf::AbstractArray: The array of planes of the facets of the STL\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.bounding_boxes_intersect-Tuple{STLCutters.Face, STLCutters.Face}","page":"Private functions","title":"STLCutters.bounding_boxes_intersect","text":"boundingboxesintersect(a::Face,b::Face)\n\nPredicate that checks if the bounding boxes of two Face intersect.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.center-Tuple{STLCutters.Face}","page":"Private functions","title":"STLCutters.center","text":"center(a::Face)\n\nIt returns the centroid of a face as the average of its vertices.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.clip-Tuple{Gridap.ReferenceFEs.Polyhedron, Any}","page":"Private functions","title":"STLCutters.clip","text":"clip(p::Polyhedron,planes;kwargs...) -> Polyhedron\n\nIt clips a polyhedron by the halfspace of a plane or a set of planes.\n\nOptional keyword arguments\n\ninside::Bool=true: It clips the polyhedron by the inside ourside of the union of halfspace.\ninout::Vector{Bool}=trues(length(planes)): In reverses the halfspaces with inside[i]=false.\nboundary::nothing:\nIf boundary=true, it preserves the vertices on the planes (zero distance)\nIf boundary=false, it removes the vertices on the planes (zero distance)\nIf boundary=nothing, it preserves the vertices on the planes if the normal of the plane points inwards.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.closest_point!","page":"Private functions","title":"STLCutters.closest_point!","text":"closest_point!(cache,point::Point,stl::DiscreteModel,[faces])\n\nIt returns the closest point to point in the stl.\n\nOptional arguments\n\nfaces::Vector{Int}: List of faces to search the closest point.\n\n\n\n\n\n","category":"function"},{"location":"functions/#STLCutters.closest_point-Tuple{AbstractVector{<:Gridap.TensorValues.VectorValue}, Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters.closest_point","text":"closest_point(points,stl::DiscreteModel)\n\nIt returns an array of Point which are the   closest_point! in the stl for each   element in points .\n\nOptional arguments\n\npoint_to_faces: Vector of vectors of the stl faces to search for each point.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.closest_point-Union{Tuple{Dp}, Tuple{Df}, Tuple{Gridap.TensorValues.VectorValue{Dp}, STLCutters.Face{Df, Dp}}} where {Df, Dp}","page":"Private functions","title":"STLCutters.closest_point","text":"closest_point(p::Point,f::Face)\n\nIt returns the closest point in a face to a point. It returns the projection   if it is inside the face, otherwise it returns the projection to the boundary.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.closest_point_to_boundary-Tuple{STLCutters.Face, Gridap.TensorValues.VectorValue}","page":"Private functions","title":"STLCutters.closest_point_to_boundary","text":"closestpointto_boundary(p::Point,f::Face)\n\nIt returns the closest point in in the boundary of f to a point p.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.collapse_small_facets!-Tuple{Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters.collapse_small_facets!","text":"collapse_small_facets!(stl::DiscreteModel)\n\nConvert small facets of the stl into edges or points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.complete_in_or_out!-Tuple{GridapEmbedded.Interfaces.AbstractEmbeddedDiscretization, GridapEmbedded.Interfaces.AbstractEmbeddedDiscretization, Any, Any}","page":"Private functions","title":"STLCutters.complete_in_or_out!","text":"complete_in_or_out!(a::AbstractEmbeddedDiscretization,b::AbstractEmbeddedDiscretization,acells,bcells)\n\nThis function considers two discretizations of the same background model on the cells acells and bcells. These sets of cells have null intersection.  If only one of the discretizations is not cut it sets the other one as in or out.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_boundary_cells-Tuple{Gridap.Geometry.DiscreteModel, PartitionedArrays.AbstractLocalIndices, Vararg{Any}}","page":"Private functions","title":"STLCutters.compute_boundary_cells","text":"compute_boundary_cells(model::DiscreteModel,indices[,d=0])\n\nIt returns the list of of own cells touching the subdomain interface.   See compute_cell_to_isboundary for more details.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_cartesian_descriptor-Tuple{Gridap.TensorValues.VectorValue, Gridap.TensorValues.VectorValue}","page":"Private functions","title":"STLCutters.compute_cartesian_descriptor","text":"compute_cartesian_descriptor(pmin,pmax;nmin,nmax)\n\nCompute CartesianDescriptor in a bounding box with the same cell size (h) in all directions:\n\nh = min( max((pmin-pmax)/nmax), min((pmax-pmin)/nmin) )\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_cell_to_facets","page":"Private functions","title":"STLCutters.compute_cell_to_facets","text":"compute_cell_to_facets(a::UnstructuredGrid,b::Grid[,a_mask])\n\ncompute_cell_to_facets computes the cells in b colliding   each cell in a:UnstructuredGrid. The output is a vector of vectors.\n\nnote: Note\nThis function uses a CartesianGrid internally. It is not optimized for higly irregular grids.\n\nnote: Note\nThis function allows false positives.\n\n\n\n\n\n","category":"function"},{"location":"functions/#STLCutters.compute_cell_to_facets-2","page":"Private functions","title":"STLCutters.compute_cell_to_facets","text":"compute_cell_to_facets(a::CartesianGrid,b::Grid[,a_mask,b_mask])\n\ncompute_cell_to_facets computes the cells in b colliding   each cell in a using optimizations for a CartesianGrid.   The output is a vector of vectors.\n\n!!! note   This function allows false positives.\n\n\n\n\n\n","category":"function"},{"location":"functions/#STLCutters.compute_cell_to_facets-Tuple{Gridap.Geometry.DiscreteModel, Any, Vararg{Any}}","page":"Private functions","title":"STLCutters.compute_cell_to_facets","text":"compute_cell_to_facets(a::DiscreteModel,b::Grid,args...)\n\nCompute a map of cells in a to the cells in b which potentially intersect.   It is designed to filter the STL faces (in b) colliding each background cell   in a. The output is a vector of vectors.\n\nnote: Note\nThis function allows false positives.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_cell_to_facets-Tuple{Gridap.Geometry.GridPortion, Any}","page":"Private functions","title":"STLCutters.compute_cell_to_facets","text":"compute_cell_to_facets(a::CartesianPortion,b::Grid)\n\ncompute_cell_to_facets computes the cells in b colliding   each cell in a:CartesianPortion.   The output is a vector of vectors.\n\nnote: Note\nThis function allows false positives.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_cell_to_isboundary","page":"Private functions","title":"STLCutters.compute_cell_to_isboundary","text":"compute_cell_to_isboundary(model::DiscreteModel,indices[,d=0])\n\nIt returns a mask whether a cell touches the subdomain interface.\n\nArguments\n\nmodel::DiscreteModel: Model of the subdomain.\nindices::AbstractLocalIndices: Partition indices\nd::Integer=0: Dimemension of the d-faces touching the subdomain interface.\n\n\n\n\n\n","category":"function"},{"location":"functions/#STLCutters.compute_distances!-Tuple{Gridap.ReferenceFEs.Polyhedron, Any, Any}","page":"Private functions","title":"STLCutters.compute_distances!","text":"compute_distances!(p::Polyhedron,planes,plane_ids[;atol=0])\n\nCompute the distances from the vertices of the polyhedron to each plane of   the list planes. If the distance is below atol, it sets the distance to   zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_face_neighbor_to_inoutcut","page":"Private functions","title":"STLCutters.compute_face_neighbor_to_inoutcut","text":"compute_face_neighbor_to_inoutcut(model::DiscreteModel,indices,d,face_to_inoutcut[,face_neighbors])\n\nIt returns a whether interfaces of dimension d are in, out, cut or undefined.\n\nThe number of interfaces coincides with the number of neigbors given by compute_face_neighbors\n\nnote: Note\nIf the subdomain is not cut, the neighbors are considered undefined.\n\n\n\n\n\n","category":"function"},{"location":"functions/#STLCutters.compute_face_neighbors-Tuple{Gridap.Geometry.DiscreteModel, PartitionedArrays.AbstractLocalIndices, Integer}","page":"Private functions","title":"STLCutters.compute_face_neighbors","text":"compute_face_neighbors(model::DiscreteModel,indices,d)\n\nIt returns a neighboring graph of the subdomain's neighbors through the interfaces of dimension d.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_grid-Tuple{Vector{<:Gridap.TensorValues.VectorValue}, AbstractArray, Gridap.ReferenceFEs.Polytope}","page":"Private functions","title":"STLCutters.compute_grid","text":"compute_grid(coordinates,connectivity,polytope)\n\nCompute a Grid from coordinates, connectivity and polytope.   It assumes that all the cells of the grid have the same polytope.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_interior_cells-Tuple{Gridap.Geometry.DiscreteModel, PartitionedArrays.AbstractLocalIndices, Vararg{Any}}","page":"Private functions","title":"STLCutters.compute_interior_cells","text":"compute_interior_cells(model::DiscreteModel,indices[,d=0])\n\nIt returns the list of of own cells not touching the subdomain interface.   See compute_cell_to_isboundary for more details.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_model-Tuple{Vector{<:Gridap.TensorValues.VectorValue}, Gridap.Arrays.Table, Gridap.ReferenceFEs.Polytope}","page":"Private functions","title":"STLCutters.compute_model","text":"compute_model(coordinates,connectivity,polytope)\n\nCompute a DiscreteModel from coordinates, connectivity and polytope.   It assumes that all the cells of the model have the same polytope.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.compute_stl_model-Union{Tuple{D}, Tuple{Vector{<:Gridap.TensorValues.VectorValue{D}}, Gridap.Arrays.Table}} where D","page":"Private functions","title":"STLCutters.compute_stl_model","text":"compute_stl_model(coordinates,connectivity)\n\nCompute a DiscreteModel from coordinates and connectivity. It assumes   that the model is surface composed of simplex faces.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.contains_projection-Tuple{STLCutters.Face, Gridap.TensorValues.VectorValue}","page":"Private functions","title":"STLCutters.contains_projection","text":"contains_projection(f::Face,p::Point)\n\nCheck is the projection of a point p is inside a face f.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.delete_repeated_vertices-Tuple{Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters.delete_repeated_vertices","text":"delete_repeated_vertices(stl::DiscreteModel [,atol])\n\nFind vertices closer than a tolerance atol and delete the repeated ones.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.displace","page":"Private functions","title":"STLCutters.displace","text":"displace(plane::AbstractPlane,dist[,oriented=true])\n\nMove a plane a distance dist along its normal vector.   If oriented is false, move a distance -dist.\n\n\n\n\n\n","category":"function"},{"location":"functions/#STLCutters.distance-Tuple{Gridap.TensorValues.VectorValue, Gridap.TensorValues.VectorValue}","page":"Private functions","title":"STLCutters.distance","text":"distance(a,b)\n\nIt returns the minimum absolute distance between two entities (Face or Point).\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.distance_to_boundary-Tuple{STLCutters.Face, Gridap.TensorValues.VectorValue}","page":"Private functions","title":"STLCutters.distance_to_boundary","text":"distance_to_infinite_face(f::Face,p::Point)\n\nIt returns the minimum distance between a point and the boundary of a face.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.distance_to_infinite_face-Union{Tuple{D}, Tuple{Gridap.TensorValues.VectorValue{D}, Gridap.TensorValues.VectorValue{D}}} where D","page":"Private functions","title":"STLCutters.distance_to_infinite_face","text":"distance_to_infinite_face(f::Face,p::Point)\n\nIt returns the minimum distance between a point and the space   where the face belongs.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.expand_face-Tuple{STLCutters.Face, Real}","page":"Private functions","title":"STLCutters.expand_face","text":"expand_face(f::Face,dist)\n\nMove the vertices of the face f a distance dist from the center of f\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.expand_planes-Tuple{AbstractVector{<:STLCutters.AbstractPlane}, AbstractVector, Any}","page":"Private functions","title":"STLCutters.expand_planes","text":"explan_planes(planes::AbstractVector{<:AbstractPlane},mask,dist)\n\nMove a list of planes a distance dist along their normal vectors. If the   mask entries are false, the planes are moved a distance -dist.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.find_root_part-Tuple{AbstractArray{<:GridapEmbedded.Interfaces.AbstractEmbeddedDiscretization}, Any}","page":"Private functions","title":"STLCutters.find_root_part","text":"find_root_part(cuts::AbstractArray{<:AbstractEmbeddedDiscretization},cells)\n\nThis functions sets the root processor to a potentially idling processor.   It returns the first non-cut part.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.get_cell!-Union{Tuple{Dc}, Tuple{Any, STLCutters.STLTopology{Dc}, Integer}} where Dc","page":"Private functions","title":"STLCutters.get_cell!","text":"get_cell!(cache,stl::STL,i::Integer)\n\nGet a cell as a Face.   It requires get_cell_cache to be allocate the cache.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.get_cell-Tuple{STLCutters.STLTopology, Integer}","page":"Private functions","title":"STLCutters.get_cell","text":"get_cell(stl::STL,i::Integer)\n\nGet a cell as a Face.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.get_cell_cache-Union{Tuple{STLCutters.STLTopology{Dc}}, Tuple{Dc}} where Dc","page":"Private functions","title":"STLCutters.get_cell_cache","text":"get_cell_cache(stl::STL)\n\nAllocate cache for get_cell!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.get_cell_planes-Tuple{Gridap.ReferenceFEs.Polytope, Any}","page":"Private functions","title":"STLCutters.get_cell_planes","text":"get_cell_planes(p::Polytope,coords::AbstractVector{<:Point})\n\nIt returns a list of planes bounding a cell. The cell is defind by   a Polytope and a list of coordinates.  If the cell is a voxel, the   bounding planes are CartesianPlane.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.get_dface!-Union{Tuple{d}, Tuple{D}, Tuple{Any, STLCutters.STLTopology{D}, Integer, Val{d}}} where {D, d}","page":"Private functions","title":"STLCutters.get_dface!","text":"get_dface!(cache,stl::STL,i::Integer,::Val{d})\n\nGet a face as a Face\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.get_dface-Union{Tuple{d}, Tuple{STLCutters.Face, Integer, Val{d}}} where d","page":"Private functions","title":"STLCutters.get_dface","text":"get_dface(f::Face,i::Integer,::Val{d})\n\nIt returns the ith d-face of a face f. E.g., vertex, edge, facet, cell.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.get_dface_cache-Tuple{STLCutters.STLTopology, Integer}","page":"Private functions","title":"STLCutters.get_dface_cache","text":"get_dface_cache(stl::STL,d::Integer)\n\nAllocate cache for get_dface!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.has_intersection-Tuple{STLCutters.Face, STLCutters.Face}","page":"Private functions","title":"STLCutters.has_intersection","text":"has_intersection(a::Face,b::Face)\n\nPredicate that checks if two faces intersect.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.has_intersection_point-Union{Tuple{D}, Tuple{Gridap.TensorValues.VectorValue, STLCutters.Face{D, D}}} where D","page":"Private functions","title":"STLCutters.has_intersection_point","text":"has_intersection(a::Face,b::Face)\n\nPredicate that checks if two faces intersect in a point.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.intersection_point-Union{Tuple{D}, Tuple{STLCutters.Face{1, D}, STLCutters.AbstractPlane{D}}} where D","page":"Private functions","title":"STLCutters.intersection_point","text":"intersection_point(a,b)\n\nIt returns the intersection point of two faces, or a face and a plane. The   intersection point is only well defined if num_dims(a)+num_dims(b)-D=0,   where D is the dimension of the space.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.is_open_surface-Tuple{Gridap.Geometry.GridTopology}","page":"Private functions","title":"STLCutters.is_open_surface","text":"is_open_surface(topo::GridTopology)\n\nPredicate to check if a surface is water tight.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.istouched","page":"Private functions","title":"STLCutters.istouched","text":"istouched(cut::AbstractEmbeddedDiscretization[,cells])\n\nCheck is an embedded discretization cut (or a set of cells) have information about the geometry. In other words, it checks if any cell is cut.\n\n\n\n\n\n","category":"function"},{"location":"functions/#STLCutters.max_length-Tuple{Gridap.Geometry.Grid}","page":"Private functions","title":"STLCutters.max_length","text":"max_length(grid::Grid)\n\nCompute the maximum of maximum length of the cells of a grid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.measure-Tuple{Gridap.Geometry.Grid, Any}","page":"Private functions","title":"STLCutters.measure","text":"measure(a::Grid,mask)\n\nCompute the sum of the cell measures of a grid. It only considers the   cells which are true in the mask.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.measure-Tuple{STLCutters.Face}","page":"Private functions","title":"STLCutters.measure","text":"measure(f::Face)\n\nIt returns the measure of a face. E.g., the length, the area or the volume.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.merge_and_collapse-Tuple{Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters.merge_and_collapse","text":"merge_and_collapse(stl::DiscreteModel)\n\nMerge close nodes and collapse small facets (convert into points or edges)   of the stl.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.merge_nodes-Tuple{Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters.merge_nodes","text":"merge_nodes(stl::DiscreteModel [,atol])\n\nMerge close nodes of the stl which are closer than a tolerance atol.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.min_height-Tuple{Gridap.Geometry.Grid}","page":"Private functions","title":"STLCutters.min_height","text":"min_height(grid::Grid)\n\nCompute the minimum of minimum heights of the cells of a grid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.min_height-Tuple{STLCutters.Face{1}}","page":"Private functions","title":"STLCutters.min_height","text":"min_height(f::Face)\n\nIt returns the minimum height of a face, i.e., the minimum distance between   two opposite entities of the face.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.normal-Tuple{STLCutters.AbstractPlane}","page":"Private functions","title":"STLCutters.normal","text":"normal(a::Plane)\n\nIt returns the normal vector of a plane\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.normal-Tuple{STLCutters.Face}","page":"Private functions","title":"STLCutters.normal","text":"normal(a::Face[,i])\n\nIt returns the normal vector of a face (or its i-th facet). Note, that the   normal is only defined for D-1 faces.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.origin-Tuple{STLCutters.AbstractPlane}","page":"Private functions","title":"STLCutters.origin","text":"origin(a::Plane)\n\nIt returns the origin point of a plane\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.orthogonal-Tuple{Gridap.TensorValues.VectorValue{2}}","page":"Private functions","title":"STLCutters.orthogonal","text":"orthogonal(a::VectorValue{D}...)\n\nIt returns the orthogonal vector to a list of D-1 vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.preprocess_small_facets-Tuple{Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters.preprocess_small_facets","text":"preprocess_small_facets(stl::DiscreteModel;atol)\n\nFix small facet problems of a quasi-degenerated stl.\n\nIf an edge and an opposite vertes are closer than atol, the edge and the   face are split. The conformity is kept in the surrounding faces.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.projection-Union{Tuple{D}, Tuple{Gridap.TensorValues.VectorValue{D}, Gridap.TensorValues.VectorValue{D}}} where D","page":"Private functions","title":"STLCutters.projection","text":"projection(p::Point,f::Face)\n\nIt returns the projection of a point p to the infinite space of f.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.propagate_inout!-NTuple{4, Any}","page":"Private functions","title":"STLCutters.propagate_inout!","text":"propagate_inout!(bgmocel,bgcell_to_inoutcut,bgnode_to_inoutcut,in_or_out)\n\nPropagates IN or OUT (in_or_out) label of each backgroun cell   (bgcell_to_inoutcut) through the nodes of the background   model (bgnode_to_inoutcut).   It overwrites bgcell_to_inoutcut`.\n\nIt is implemented with a deep-first search algorithm that stops at CUT cells.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.read_stl-Tuple{String}","page":"Private functions","title":"STLCutters.read_stl","text":"read_stl(filename)\n\nRead STL file with MeshIO.jl and Gridap.jl arrays:\n\nvertex_to_coordinates is a vector of Point{3,Float64}\nfacet_to_vertices is a Gridap.Table of Int\nfacet_to_normals is a vector of VectorValue{3,Float64}\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.save_as_stl-Tuple{Vector{<:Gridap.Geometry.DiscreteModel}, Any}","page":"Private functions","title":"STLCutters.save_as_stl","text":"save_as_stl(stl::Vector{<:DiscreteModel},filename)\n\nSave a list of DiscreteModel{2,3} into STL files. It save the files as   filename_1.stl, filename_2.stl,..., filename_n.stl`.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.save_as_stl-Union{Tuple{Dp}, Tuple{Dc}, Tuple{Gridap.Geometry.DiscreteModel{Dc, Dp}, Any}} where {Dc, Dp}","page":"Private functions","title":"STLCutters.save_as_stl","text":"save_as_stl(stl::DiscreteModel,filename)\n\nSave DiscreteModel{2,3} into a STL file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.set_in_or_out!-Tuple{STLCutters.STLEmbeddedDiscretization, Vararg{Any}}","page":"Private functions","title":"STLCutters.set_in_or_out!","text":"set_in_or_out!(cut::DistributedEmbeddedDiscretization,in_or_out[,cells,facets])\n\nSets all the background cells and facets (or a set of cells and facets) as in or out.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.signed_distance-Tuple{Gridap.TensorValues.VectorValue, STLCutters.Plane}","page":"Private functions","title":"STLCutters.signed_distance","text":"signed_distance(p::Point,Π::AbstractPlane)\n\nIt returns the signed distance between a point and a plane.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.simplex_face-Tuple{Vararg{Gridap.TensorValues.VectorValue}}","page":"Private functions","title":"STLCutters.simplex_face","text":"simplex_face(x::Point...)\n\nIt returns a simplex face from a list (or a tuple) of points. The dimension of   the simplex is N+1, where N is the number of points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.simplexify_boundary-Tuple{Gridap.ReferenceFEs.Polyhedron{3}, Gridap.Geometry.GridTopology}","page":"Private functions","title":"STLCutters.simplexify_boundary","text":"simplexify_boundary(p::Polyhedron,t::GridTopology)\n\nIt generates a simplex mesh of the surface of the polyhedron that touches the   grid topology.\n\nIt returns the coordinates of the vertices, the connectivities and a mapping   to the topology facets.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.split_disconnected_parts-Tuple{Gridap.Geometry.DiscreteModel}","page":"Private functions","title":"STLCutters.split_disconnected_parts","text":"split_disconnected_parts(stl::DiscreteModel)\n\nGiven a stl with disconnected parts, it returns an array of DiscreteModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.surface-Union{Tuple{Dp}, Tuple{Df}, Tuple{Gridap.Geometry.Grid{Df, Dp}, Vararg{Any}}} where {Df, Dp}","page":"Private functions","title":"STLCutters.surface","text":"surface(a::Grid)\n\nCompute the surface of a grid. It returns the measure of a surface   grid, i.e-, Dc=D-1.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.volume-Union{Tuple{D}, Tuple{Gridap.Geometry.Grid{D, D}, Vararg{Any}}} where D","page":"Private functions","title":"STLCutters.volume","text":"volume(a::Grid)\n\nCompute the volume of a grid. It returns the measure of the grid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#STLCutters.voxel_intersection-Tuple{STLCutters.Face{1, 2}, Gridap.TensorValues.VectorValue, Gridap.TensorValues.VectorValue, Gridap.ReferenceFEs.Polytope}","page":"Private functions","title":"STLCutters.voxel_intersection","text":"voxel_intersection(f::Face,pmin::Point,pmax::Point,p::Polytope)\n\nPredicate that checks if a face intersects by a voxel. Here, a voxel is a   hypercube defined by its extrema (pmin and pmax).\n\nnote: Note\nThis function can return false positives.\n\n\n\n\n\n","category":"method"},{"location":"public_api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"Pages = [\"public_api.md\"]","category":"page"},{"location":"public_api/","page":"Public API","title":"Public API","text":"CurrentModule = STLCutters","category":"page"},{"location":"public_api/","page":"Public API","title":"Public API","text":"STLCutters.cut\nsubtriangulate\nSTLCutter\nSTLGeometry\ndownload_thingi10k\ncheck_requisites","category":"page"},{"location":"public_api/#GridapEmbedded.Interfaces.cut","page":"Public API","title":"GridapEmbedded.Interfaces.cut","text":"cut([cutter::STLCutter,]model::DiscreteModel,geo::STLGeometry)\n\nMain interface of GridapEmbedded. It intersect each cell in model with the geometry geo. It returns an embedded discretization.\n\nUsage\n\nThe basic usage is to call cut with a model and a geometry.\n\ncutgeo = cut(model,geo)\n\nWe can also set custom keyword arguments, see subtriangulate.\n\ncutter = STLCutter(;tolfactor=1e3)\ncutgeo = cut(cutter,model,geo)\n\nThen we can extract the domain and the boundary of the embedded discretization.\n\nΩ = Triangulation(cutgeo)\nΓ = EmbeddedBoundary(cutgeo)\n\n\n\n\n\n","category":"function"},{"location":"public_api/#STLCutters.subtriangulate","page":"Public API","title":"STLCutters.subtriangulate","text":"subtriangulate(bgmodel::DiscreteModel,stl::DiscreteModel;kwargs...)\n\nIntersection of each background cell in bgmodel with domain bounded by the   stl surface.\n\nIt returns a three grids and set of lables:\n\ncell_grid: cell-wise volume grid of the intersection of each background cell and the interior of the domain.\nface_grid: cell-wise surface grid of the intersection of each background cell and the stl surface.\nbface_grid: facet-wise surface grid of the intersection of each background (d-1)-face and the interior of the domain.\nlabels: SubtriangulationLabels label IN/OUT/CUT, background cell, background face or STL face.\n\nOptional keywords arguments:\n\nkdtree: (default false) if true it uses a kdtree as a first step\ntolfactor: (default 1e3) relative tolerance with respect to machine  precision (e.g., 1e-16*max_length(bgmodel))\nsurfacesource: (default :skin) source of the face_grid.\n:skin: the face_grid is the intersection of the stl surface\n:interior: the face_grid is extracted of the interior cell_grid\n:exterior: the face_grid is extracted of the exterior `cell_grid\n:both: retunrs boths :interior and :exterior face_grid. It must be filtered (only used for debugging purposes).\nshowprogress: (default true) show progress bar\nall_defined: (default true) if true all cells are defined as IN, OUT or CUT. If false undefined cells are allowed (only used for distributed meshes)\ncell_to_facets: (default compute_cell_to_facets) precomputed cell to stl facets mapping.\n\n\n\n\n\n","category":"function"},{"location":"public_api/#STLCutters.STLCutter","page":"Public API","title":"STLCutters.STLCutter","text":"struct STLCutter <: GridapEmbedded.Interfaces.Cutter\n\nCutter type for STLGeometries, it stores the keyword arguments of   subtriangulate.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#STLCutters.STLGeometry","page":"Public API","title":"STLCutters.STLGeometry","text":"struct STLGeometry <: GridapEmbedded.CSG.Geometry\n\nObject that stores the SLT geometry.\n\nExample\n\njulia> filename = download_thingi10k(293137)\njulia> geo = STLGeometry(filename)\njulia> writevtk(geo,\"geo\")\n\n\n\n\n\n","category":"type"},{"location":"public_api/#STLCutters.download_thingi10k","page":"Public API","title":"STLCutters.download_thingi10k","text":"download_thingi10k(id;path\"\")\n\nDowloads surface model from thingiverse indexed by FileID at Thingi10K.\n\nIt returns the path to the downloaded file.\n\nExample\n\njulia> download_thingi10k(293137)\n\"293137.stl\"\n\n\n\n\n\n","category":"function"},{"location":"public_api/#STLCutters.check_requisites","page":"Public API","title":"STLCutters.check_requisites","text":"check_requisites(stl::DiscreteModel,bgmodel::DiscreteModel)\n\nCheck if the stl meets the requirements to be used in the cutter.\n\nKeyword arguments\n\nverbose::Bool=false: Print the results of the check.\nmax_num_facets::Int=10000: Maximum number of facets per background cell.\n\nThe requirements are the following:\n\nIs a surface\nIs vertex manifold\nIs edge manifold\nIs water tight\nHas no sharp edges\nHas number of STL faces per background cell less than a max_num_facets (default is 10000)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Installation","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"STLCutters is a registered package. You can install it by running:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Use ] to enter the Pkg REPL mode\npkg> add STLCutters","category":"page"},{"location":"usage/#Load-package","page":"Usage","title":"Load package","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Load the package normally with","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using STLCutters","category":"page"},{"location":"usage/#Downloading-STL-files","page":"Usage","title":"Downloading STL files","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The STLCutters package works with STL files. Therefore, first, you need to create or download an STL file. The Thingi10k dataset is one of the options for testing. You can download any indexed geometry with download_thingi10k. E.g.,","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"filename = download_thingi10k(293137)","category":"page"},{"location":"usage/#Discretization","page":"Usage","title":"Discretization","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Since STLCutters is an extension of GridapEmbedded, it utilizes the same workflow to solve PDEs on embedded domains. In particular, STLCutters extends the cut function from GridapEmbedded.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We load the STL file with an STLGeometry object. E.g.,","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"filename = download_thingi10k(293137)\ngeo = STLGeometry(filename)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Then, we define a DiscreteModel around, e.g., a CartesianDiscreteModel.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"pmin,pmax = get_bounding_box(geo)\nmodel = CartesianDiscreteModel(pmin,pmax,())","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now, we can cut the model with the STLGeometry.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"cutgeo = cut(model,geo)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Note\nSome STL files may not be properly defined. It is recommended to check the requisites before proceeding with check_requisites. In particular, one checks if the STL is a closed surface, a manifold and has a bounded density of faces.","category":"page"},{"location":"usage/#Usage-with-Gridap","page":"Usage","title":"Usage with Gridap","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Once the geometry is discretized, one can generate the embedded triangulations to solve PDEs with Gridap, see also Gridap Tutorials.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Like in GridapEmbedded, we extract the embedded triangulations as follows.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Ωact = Triangulation(cutgeo,ACTIVE)\nΩ = Triangulation(cutgeo)\nΓ = EmbeddedBoundary(cutgeo)\nΛ = SkeletonTriangulation(cutgeo)","category":"page"},{"location":"usage/#Serial-example","page":"Usage","title":"Serial example","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now, we provide an example of the solution of a Poisson problem on the embedded domain.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using STLCutters\nusing Gridap\nusing GridapEmbedded\ncells = (10,10,10)\nfilename = \"stl_file_path.stl\"\n# Domain and discretization\ngeo = STLGeometry(filename)\npmin,pmax = get_bounding_box(geo)\nmodel = CartesianDiscreteModel(pmin,pmax,cells)\ncutgeo = cut(model,geo)\n# Cell aggregation\naggregates = aggregate(AggregateAllCutCells(),cutgeo)\n# Triangulations\nΩ_act = Triangulation(cutgeo,ACTIVE)\nΩ = Triangulation(cutgeo)\nΓ = EmbeddedBoundary(cutgeo)\nnΓ = get_normal_vector(Γ)   \ndΩ = Measure(Ω,2)\ndΓ = Measure(Γ,2)\n# FE spaces\nVstd = TestFESpace(Ω_act,ReferenceFE(lagrangian,Float64,1))\nV = AgFEMSpace(Vstd,aggregates)\nU = TrialFESpace(V)\n# Weak form\nγ = 10.0\nh = (pmax - pmin)[1] / cells[1]\nud(x) = x[1] - x[2]\nf = 0\na(u,v) =\n    ∫( ∇(v)⋅∇(u) )dΩ +\n    ∫( (γ/h)*v*u  - v*(nΓ⋅∇(u)) - (nΓ⋅∇(v))*u )dΓ\nl(v) =\n    ∫( v*f )dΩ +\n    ∫( (γ/h)*v*ud - (nΓ⋅∇(v))*ud )dΓ\n# Solve\nop = AffineFEOperator(a,l,U,V)\nuh = solve(op)\nwritevtk(Ω,\"results\",cellfields=[\"uh\"=>uh])","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Note\nThe STL file can be downloaded using download_thingi10k.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Note\nOne can consider a different stabilization of the small cut-cell problem instead of AgFEM. Then, the aggregate and AgFEMSpace need to be removed. See more examples in GridapEmbedded","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"You are welcome to contribute to the development of STLCutters.jl. Please, follow the  Gridap contributing guidelines","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In these slides you can find a presentation with more details of the package and guidelines for contributing.","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"theme: gaia paginate: true marp: true author: Pere Antoni Martorell backgroundColor: white title: STLCutters.jl backgroundPosition: center footer: P. A. Martorell | STLCutters.jl | 01-08-2024 style: |   .columns {     display: grid;     grid-template-columns: repeat(2, minmax(0, 1fr));     gap: 1rem;   }   .image-row {     display: flex;     justify-content: space-between; /* this will add equal space between each image      */   }   .outline {     padding-top:50px;     padding-left:100px;     font-size:40px;   }","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<style> section {   padding-top: 10px; } </style>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<!– _paginate: skip–> <!– _footer: \"\" –> <!– _backgroundColor:  #f2f4f4 –>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"text-align:center;padding-top:70px\">","category":"page"},{"location":"assets/slides-2024-08-01/main/#STLCutters.jl","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Pere Antoni Martorell ","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"1 Aug 2024","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"position:absolute;top:150px;left:25px\">   <img src=\"figures/arctriomphelasticity.png\" height=350> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"position:absolute;top:100px;right:25px\">   <img src=\"figures/arctrimphlic_flow.png\" height=400> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"position:relative;bottom:-250px;width:1000px;left:70px;background-color:white\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"image-row\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<img src=\"logos/cimne-so.png\" alt=\"CIMNE\" height=70 >","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<img src=\"logos/upc-complet.png\" alt=\"UPC\" height=80>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<img src=\"logos/Monash-logo.png\" alt=\"UPC\" height=80>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<img src=\"logos/gridap.png\" alt=\"Gridap\" height=80>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"position:absolute;bottom:20px;right:10px\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:100) </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<!– backgroundColor:  white –> <!– _backgroundColor:  white –>","category":"page"},{"location":"assets/slides-2024-08-01/main/#Outline","page":"STLCutters.jl","title":"Outline","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"outline\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Why STLCutters.jl\nWhat is STLCutters.jl\nHow to use and contribute\nFuture Work\nHands-on & Questions","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Outline-2","page":"STLCutters.jl","title":"Outline","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"outline\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Why STLCutters.jl\nWhat is STLCutters.jl\nHow to use and contribute\nFuture Work\nHands-on & Questions","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Unfitted-Finite-Elements","page":"STLCutters.jl","title":"Unfitted Finite Elements","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"text-align:center\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1150)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:500)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Unfitted-Geometries","page":"STLCutters.jl","title":"Unfitted Geometries","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"text-align:center;vertical-align:center\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1000)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"font-size:15px\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"S. Badia, P. A. Martorell, F. Verdugo. Geometrical discretisations for unfitted finite elements on explicit boundary representations. J. Comput. Phys. 460 (2022): 111162.","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Long-term-goals","page":"STLCutters.jl","title":"Long term goals","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"border: 10px solid #b7950b;border-radius: 20px; ;padding-left:50px;padding-top:0px;padding-bottom:0px;font-size:25px;background-color:#fcf3cf\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Fluid-structure interaction (FSI) on unfitted FEM","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Discretizations for real STL and CAD geometries\nFSI solvers for unfitted FE\nLarge-scale computations","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"My PhD Thesis:","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"columns\" style=\"font-size:25px\"> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"✅ Discretization on STL geometries ✅ High-order discretizations for CAD geometries (private repo) ✅ Space-time transient unfitted FE (private repo) ✅ Distributed memory parallelism","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"❌ Fluid-structure interaction (FSI) and multiphysics ❌ Adaptive mesh refinement (AMR) ❌ Large-scale computations","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<!– TODO: focus on FSI and large-scale –>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Outline-3","page":"STLCutters.jl","title":"Outline","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"outline\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Why STLCutters.jl\nWhat is STLCutters.jl\nHow to use and contribute\nFuture Work\nHands-on & Questions","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Gridap-and-Julia","page":"STLCutters.jl","title":"Gridap and Julia","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1100)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Cell-wise-intersection","page":"STLCutters.jl","title":"Cell-wise intersection","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1100)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Achievements:-Robustness","page":"STLCutters.jl","title":"Achievements: Robustness","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<small>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"epsilon _v =  V_mathrmin + V_mathrmout - V_mathrmbox   V_mathrmbox  10^-10","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"for 100% of 4726 STLs in Thingi10K","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</small>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1100)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Achievements:-Robustness-2","page":"STLCutters.jl","title":"Achievements: Robustness","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"text-align:center\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1000)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Achievements:-Parallel-Scalability","page":"STLCutters.jl","title":"Achievements: Parallel Scalability","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"text-align:center\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:900)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"text-align:center; font-weight:bold \"> <small> ⚠️ Unpublished results! </small> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Outline-4","page":"STLCutters.jl","title":"Outline","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"outline\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Why STLCutters.jl\nWhat is STLCutters.jl\nHow to use and contribute\nFuture Work\nHands-on & Questions","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Using-STLCutters.jl","page":"STLCutters.jl","title":"Using STLCutters.jl","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"columns\"> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Install","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"] add STLCutters                                     ","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Or download","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"git clone https://github.com/gridap/STLCutters.jl.git","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Gridap & GridapEmbedded API\nGridapDistributed & GridapP4est compatibility","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: )","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Distributed-usage","page":"STLCutters.jl","title":"Distributed usage","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"columns\"> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"mpiexec -np 8 julia example.jl","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:550)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"] add GridapP4est","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:550px)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Distributed-usage-2","page":"STLCutters.jl","title":"Distributed usage","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"padding-top:70px\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1100)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Adaptive-Mesh-Refinement-(AMR)","page":"STLCutters.jl","title":"Adaptive Mesh Refinement (AMR)","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"columns\"> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"2:1 k-balanced in p4est","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"flags = adapt_cut_cells(parts,cutgeo)\nmodel, = Gridap.Adaptivity.adapt(model,flags)\ncutgeo = cut(model,geo)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:650)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Coding-style","page":"STLCutters.jl","title":"Coding style","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Gridap-like coding style\nSemantic Versioning: Julia registry, registered dependencies\nGitHub Utilities: Issues, PRs, CI\nDocumentation: docstrings, documentation pages","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Code-structure","page":"STLCutters.jl","title":"Code structure","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"vertical-align:center;padding-top:20px\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1100)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Code-structure-2","page":"STLCutters.jl","title":"Code structure","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div style=\"vertical-align:center;padding-top:20px\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1100)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Package-files","page":"STLCutters.jl","title":"Package files","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"src/: 5k code lines ├── STLCutters.jl: Main module with imports and exports ├── SubTriangulations.jl: Core of the package with main algorithms ├── STLs.jl: Load, clean and manage STL geometries ├── Polyhedra.jl: General polytope operations ├── SimplexFaces.jl: Geometrical operations on simplicies ├── Embedded.jl: Extending GridapEmbedded API └── Distributed.jl: Extending distributed functions and algorithms","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Core-procedures","page":"STLCutters.jl","title":"Core procedures","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"columns\"> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"function subtriangulate(stl,bgmodel)\nc_to_f = compute_cell_to_facets(bgmodel,stl)\nsubmesh = _empty_submesh()\nfor cell in findall(!isempty,c_to_f)\n    Γ = stl[c_to_f[cell]]\n    P = compute_polyhedra(cell,bgmodel,Γ)\n    save_cell_submesh!(submesh,cell,P...)\nend\npropagate_inout!(submesh)\ndelete_small_cells(submesh)\ngrids = compute_grids(submesh)\nlabels = SubtriangulationLabels(submesh)\nreturn grids,labels\nend","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> <div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"function compute_polyhedra(cell,bgmodel,Γ)\nK = Polyhedron(bgmodel,cell)\nΓk = clip(Γ,planes(K))  \nKin,Kout = refine(K,planes(Γk),reflex_planes(Γk))\nreturn Kin,Kout,Γk\nend","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"function save_cell_submesh!(submesh,cell,Kin,Kout,Γk)\n_submesh,_face_submesh = submesh\nappend!(_submesh,cell,simplexify(Kin),simplexify(Kout))\nappend!(_face_submesh,cell,simplexify(Γk))\nend","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div> </div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"ℹ️ Some functions have been simplified for demonstration purposes","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Outline-5","page":"STLCutters.jl","title":"Outline","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"<div class=\"outline\">","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Why STLCutters.jl\nWhat is STLCutters.jl\nHow to use and contribute\nFuture Work\nHands-on & Questions","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"</div>","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Future-Work","page":"STLCutters.jl","title":"Future Work","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Extract mesh of general polytopes STLCutters.jl#37\nReduce memory allocations STLCutters.jl#38\nDeal with disconnected subdomains STLCutters.jl\nDistribute space-time methods STLCutters.jl\nAMR with unfitted AgFEM GridapEmbedded.jl\nFix moment fitting in parallel GridapEmbedded.jl#94\nSolve void subdomains GridapDistributed.jl\nTest distributed solvers on unfitted FSI","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Acknowledgments","page":"STLCutters.jl","title":"Acknowledgments","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Special acknowledgments:\nSupervisors: Santiago Badia & Francesc Verdugo\nContributors: STLCutters & Gridap ecosystem\nUsers\nYou\nThanks for giving a star on GitHub","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"(Image: w:1100)","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"","category":"page"},{"location":"assets/slides-2024-08-01/main/#Hands-on-and-Questions","page":"STLCutters.jl","title":"Hands-on & Questions","text":"","category":"section"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"Visit the GitHub page: https://github.com/gridap/STLCutters.jl\nCheck the documentation: https://gridap.github.io/STLCutters.jl\nLocally navigate the repository & run examples:","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"git clone https://github.com/gridap/STLCutters.jl.git\ncode STLCutters.jl","category":"page"},{"location":"assets/slides-2024-08-01/main/","page":"STLCutters.jl","title":"STLCutters.jl","text":"julia> include(\"examples/LinearElasticity.jl\")\njulia> filename = \"test/data/550964.stl\"\njulia> LinearElasticity.main(filename,n=50,force=(tand(5),0,-1),output=\"example4\")","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"distributed/#Distributed","page":"Distributed","title":"Distributed","text":"","category":"section"},{"location":"distributed/#Introduction","page":"Distributed","title":"Introduction","text":"","category":"section"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"When dealing with large-scale problems, this package can be accelerated through two types of parallelization. The first one is multi-threading, which uses Julia Threads for shared memory parallelization (e.g., julia -t 4). This method adds some speed-up. However, it is only efficient for a reduced number of threads.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"The second one is a distributed memory computing. For such parallelization, we use MPI (mpiexec -np 4 julia input.jl) through PartitionedArrays and GridapDistributed. With MPI we can compute large-scale problems efficiently, up to thousands of cores.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"Additionally, the distributed memory implementation is built on top of GridapEmbedded. GridapEmbedded provides parallelization tools since v0.9.2.","category":"page"},{"location":"distributed/#Underlying-distributed-algorithms","page":"Distributed","title":"Underlying distributed algorithms","text":"","category":"section"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"The implementation of multi-threading is straightforwardly applied to the embarrassingly parallel loops. However, the distributed memory implementation requires more involved algorithms for the global computations, e.g., the classification of the background cells as inside or outside. These algorithms are described in Chapter 4 of the following PhD thesis.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"Pere A. Martorell. \"Unfitted finite element methods for explicit boundary representations\". PhD Thesis. Universitat Politècnica de Catalunya. 2024. hdl.handle.net/10803/690625","category":"page"},{"location":"distributed/#Multi-threading-usage","page":"Distributed","title":"Multi-threading usage","text":"","category":"section"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"The usage of this package with multi-threading is the same as for the serial case (see Serial example). The user only needs to set the number of threads when initializing Julia. E.g.,","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"julia -threads 4 ","category":"page"},{"location":"distributed/#Distributed-memory-usage","page":"Distributed","title":"Distributed memory usage","text":"","category":"section"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"The distributed usage needs to be set up at the driver level. The user needs to install and load MPI.jl, PartitionedArrays.jl, and GridapDistributed.jl. ","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"Here, we provide a basic example of solving the Poisson equation with distributed STLCutters with 8 MPI tasks. Run the following command.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"mpiexec -np 8 julia poisson.jl","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"note: Note\nInstead of running mpiexec -np 8 julia poisson.jl, it is recommended to use the mpiexec function from the MPI.jl package.using MPI\nmpiexec() do cmd\n    run(`$cmd -np 8 $(Base.julia_cmd()) --project=$(Base.active_project()) poisson.jl`)\nend","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"Where poisson.jl is the following code.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"using STLCutters\nusing Gridap\nusing GridapEmbedded\nusing GridapDistributed\nusing PartitionedArrays\nparts = (2,2,2)\ncells = (10,10,10)\nfilename = \"stl_file_path.stl\"\nwith_mpi() do distribute\n  ranks = distribute(LinearIndices((prod(parts),)))\n  # Domain and discretization\n  geo = STLGeometry(filename)\n  pmin,pmax = get_bounding_box(geo)\n  model = CartesianDiscreteModel(ranks,parts,pmin,pmax,cells)\n  cutgeo = cut(model,geo)\n  # Cell aggregation\n  model,cutgeo,aggregates = aggregate(AggregateAllCutCells(),cutgeo)\n  # Triangulations\n  Ω_act = Triangulation(cutgeo,ACTIVE)\n  Ω = Triangulation(cutgeo)\n  Γ = EmbeddedBoundary(cutgeo)\n  nΓ = get_normal_vector(Γ)   \n  dΩ = Measure(Ω,2)\n  dΓ = Measure(Γ,2)\n  # FE spaces\n  Vstd = TestFESpace(Ω_act,ReferenceFE(lagrangian,Float64,1))\n  V = AgFEMSpace(model,Vstd,aggregates)\n  U = TrialFESpace(V)\n  # Weak form\n  γ = 10.0\n  h = (pmax - pmin)[1] / cells[1]\n  ud(x) = x[1] - x[2]\n  f = 0\n  a(u,v) =\n    ∫( ∇(v)⋅∇(u) )dΩ +\n    ∫( (γ/h)*v*u  - v*(nΓ⋅∇(u)) - (nΓ⋅∇(v))*u )dΓ\n  l(v) =\n    ∫( v*f )dΩ +\n    ∫( (γ/h)*v*ud - (nΓ⋅∇(v))*ud )dΓ\n  # Solve\n  op = AffineFEOperator(a,l,U,V)\n  uh = solve(op)\n  writevtk(Ω,\"results\",cellfields=[\"uh\"=>uh])\nend","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"note: Note\nThe STL file can be downloaded using download_thingi10k.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"note: Note\nIt is recommended to use with_debug() instead of with_mpi() for debugging in serialized execution, see more details in PartitionedArrays.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"note: Note\nOne can consider a different stabilization of the small cut-cell problem instead of AgFEM. Then, the aggregate and AgFEMSpace need to be removed. See more examples in GridapEmbedded","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"warning: Warning\nEven though the distributed algorithms are proven to be efficient for large-scale weak scaling tests Martorell, 2024. The performance of this implementation is not tested.","category":"page"},{"location":"distributed/#Usage-with-p4est","page":"Distributed","title":"Usage with p4est","text":"","category":"section"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"The implementation is general for all the Gridap.jl triangulations.  Thus, we can use p4est through GridapP4est.jl in order to exploit its features. With p4est, we can take advantage of adaptive mesh refinement (AMR) and redistribution. ","category":"page"},{"location":"distributed/#Redistribute-with-p4est","page":"Distributed","title":"Redistribute with p4est","text":"","category":"section"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"The following example is using redistribute to improve the load balancing of the subdomains.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"using STLCutters\nusing Gridap\nusing GridapEmbedded\nusing GridapDistributed\nusing PartitionedArrays\nusing GridapP4est\nparts = 8\ncells = (2,2,2)\nfilename = \"293137.stl\"\nwith_mpi() do distribute\n  ranks = distribute(LinearIndices((prod(parts),)))\n  # Domain and discretization\n  geo = STLGeometry(filename)\n  pmin,pmax = get_bounding_box(geo)\n  coarse_model = CartesianDiscreteModel(pmin,pmax,cells)\n  model = OctreeDistributedDiscreteModel(ranks,coarse_model,2)\n  cutgeo = cut(model,geo)\n  # Redistribute to avoid void subdmoains\n  weights = compute_resdistribute_weights(cutgeo)\n  model, = GridapDistributed.redistribute(model,weights=weights)\n  # Re-compute discretization\n  cutgeo = cut(model,geo)\n  # Cell aggregation\n  model,cutgeo,aggregates = aggregate(AggregateAllCutCells(),cutgeo)\n  # Triangulations\n  Ω_act = Triangulation(cutgeo,ACTIVE)\n  Ω = Triangulation(cutgeo)\n  Γ = EmbeddedBoundary(cutgeo)\n  nΓ = get_normal_vector(Γ)\n  dΩ = Measure(Ω,2)\n  dΓ = Measure(Γ,2)\n  # FE spaces\n  Vstd = TestFESpace(Ω_act,ReferenceFE(lagrangian,Float64,1))\n  V = AgFEMSpace(model,Vstd,aggregates)\n  U = TrialFESpace(V)\n  # Weak form\n  γ = 10.0\n  h = (pmax - pmin)[1] / cells[1]\n  ud(x) = x[1] - x[2]\n  f = 0\n  a(u,v) =\n    ∫( ∇(v)⋅∇(u) )dΩ +\n    ∫( (γ/h)*v*u  - v*(nΓ⋅∇(u)) - (nΓ⋅∇(v))*u )dΓ\n  l(v) =\n    ∫( v*f )dΩ +\n    ∫( (γ/h)*v*ud - (nΓ⋅∇(v))*ud )dΓ\n  # Solve\n  op = AffineFEOperator(a,l,U,V)\n  uh = solve(op)\n  writevtk(Ω,\"results\",cellfields=[\"uh\"=>uh])\nend","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"note: Note\nFor compatibility reasons, we are not interested on adding GridapP4est as a dependency. The interested can add it to its own driver. ","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"note: Note\nThe compute_resdistribute_weights is a GridapEmbedded function since #95","category":"page"},{"location":"distributed/#Adaptive-mesh-refinement-with-p4est","page":"Distributed","title":"Adaptive mesh refinement with p4est","text":"","category":"section"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"The p4est library is designed to provide AMR. In the following example, we can adapt a mesh using the STLCutters.jl output and generate a new discretization on the refined mesh. Using STLCutters.jl works out-of-the-box with 2:1 balanced adapted meshes. The user can use this discretization to solve partial differential equations and combine them with redistribute.","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"using STLCutters\nusing Gridap\nusing GridapEmbedded\nusing GridapDistributed\nusing PartitionedArrays\nusing GridapP4est\nparts = 8\ncells = (16,16,16)\nfilename = \"293137.stl\"\nwith_mpi() do distribute\n  ranks = distribute(LinearIndices((prod(parts),)))\n  # Domain and discretization\n  geo = STLGeometry(filename)\n  pmin,pmax = get_bounding_box(geo)\n  coarse_model = CartesianDiscreteModel(pmin,pmax,cells)\n  model = OctreeDistributedDiscreteModel(ranks,coarse_model)\n  cutgeo = cut(model,geo)\n  # Redistribute to avoid void subdmoains\n  flags = compute_adaptive_flags(cutgeo)\n  model, = Gridap.Adaptivity.adapt(model,flags)\n  model = Gridap.Adaptivity.get_model(model.dmodel)\n  # Re-compute discretization\n  cutgeo = cut(model,geo)\n  Ωin = Triangulation(cutgeo,PHYSICAL_IN)\n  Ωout = Triangulation(cutgeo,PHYSICAL_OUT)\n  Ωbg = Triangulation(model)\n  dΩin = Measure(Ωin,2)\n  dΩout = Measure(Ωout,2)\n  dΩbg = Measure(Ωbg,2)\n  e = ∑( ∫(1)dΩin ) + ∑( ∫(1)dΩout ) - ∑( ∫(1)dΩbg )\n  i_am_main(ranks) && println(\"Volume error: $e\")\n  writevtk(Ωin,\"trian\")\n  writevtk(Ωbg,\"trian_bg\")\nend","category":"page"},{"location":"distributed/","page":"Distributed","title":"Distributed","text":"note: Note\nThe compute_adaptive_flags is a GridapEmbedded function since #95","category":"page"},{"location":"#STLCutter.jl","page":"Introduction","title":"STLCutter.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation for STLCutters.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThese documentation pages are under construction.","category":"page"},{"location":"#What","page":"Introduction","title":"What","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides the tools for solving partial differential equations (PDEs) on domains bounded by STL surfaces. STLCutters is an extension of GridapEmbedded. GridapEmbedded is a package for solving  PDEs on embedded domains, e.g., using embedded, unfitted or immersed finite element methods. Both, GridapEmbedded and STLCutters build on top of Gridap.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In the following work, you can find the research related with STLCutters:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Santiago Badia, Pere A. Martorell, Francesc Verdugo. \"Geometrical discretisations for unfitted finite elements on explicit boundary representations.\" Journal of Computational Physics 460 (2022): 111162. doi: 10.1016/j.jcp.2022.111162","category":"page"},{"location":"#Why","page":"Introduction","title":"Why","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The simulation of industrial and scientific problems involves solving PDEs on complex geometries. The generation of body-fitted unstructured meshes requires extensive human intervention. Additionaly, mesh partitioners are inherently serial and represent a botleneck (or a limitation) in the parallelization. Embedded methods (e.g., GridapEmbedded) address this limitation by using simple (e.g., structured) meshes for the functional discretization.. However, these methods define the domain through implicit functions (i.e., level sets) which represents a significant limitation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package addresses explicit boundary representations with embedded methods. Specifically, we provide algorithmic tools for the discretizations of embedded methods on STL surfaces. The implementations are designed to be efficient in large-scale distributed memory environments.","category":"page"},{"location":"types/#Private-types","page":"Private types","title":"Private types","text":"","category":"section"},{"location":"types/","page":"Private types","title":"Private types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"types/","page":"Private types","title":"Private types","text":"Modules = [STLCutters]\nPublic = false\nOrder   = [:type]","category":"page"},{"location":"types/#STLCutters.AbstractPlane","page":"Private types","title":"STLCutters.AbstractPlane","text":"abstract type AbstractPlane\n\nPlane type used to compute intersections. It can be accessed by   normal and origin.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.CartesianPlane","page":"Private types","title":"STLCutters.CartesianPlane","text":"struct CartesianPlane{D,T}<:AbstractPlane{D,T}\n\nPlane defined by a Cartesian axis and one single Cartesian coordinate.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.Face","page":"Private types","title":"STLCutters.Face","text":"abstract type Face{Df,Dp}\n\nFace type used to compute intersections with multiple dispatching.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.Plane","page":"Private types","title":"STLCutters.Plane","text":"struct Plane{D,T}<:AbstractPlane{D,T}\n\nPlane defined by an origin point and a normal vector.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.PolyhedronData","page":"Private types","title":"STLCutters.PolyhedronData","text":"PolyhedronData\n\nMetadata for Gridap.ReferenceFEs.GeneralPolytope that serves for performing geometrical   operations.\n\nThe metadata stores the following information:     * vertex_to_planes: A list of planes that intersect each vertex.     * vertex_to_original_faces: A list of d-faces of the original polytope or STL     * vertex_to_parent_vertex: It maps a vertex to a vertex that has the same coordinates     * vertex_to_parent_edge: It maps a vertex a vertex pair that generated that vertex     * plane_to_vertex_to_distances: A list of distances from each plane to each vertex     * plane_to_ref_plane: It maps a plane to a plane that (almost) co-planar     * plane_to_ids: It maps the plane to the plane id\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.STL","page":"Private types","title":"STLCutters.STL","text":"const STL = STLTopology\n\nAlias STLTopology as STL.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.STLTopology","page":"Private types","title":"STLCutters.STLTopology","text":"struct STLTopology{Dc,Dp,T} <: GridTopology{Dc,D}\n\nSTLTopology is a Gridap.GridTopology without lazy arrays.   It reduces computations when accessing their properties. It is used to   save the STL geometries. It is alliased as STL.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.Segment","page":"Private types","title":"STLCutters.Segment","text":"struct Segment{D,T}<:Face{1,D}\n\n1-dimensional Face defined by two points.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.SubtriangulationLabels","page":"Private types","title":"STLCutters.SubtriangulationLabels","text":"SubtriangulationLabels\n\nLabels for the sub grids of subtriangulate.\n\nIt stores the following fields:\n\ncell_to_bgcell: subcell to background cell\ncell_to_io: subcell to IN/OUT\nface_to_stlface: subface to STL face\nface_to_bgcell: subface to background cell\nface_to_ios: subface to surface source (IN,OUT,SKIN)\nbgcell_to_ioc: background cell to IN/OUT/CUT\nbgface_to_ioc: background face to IN/OUT/CUT\nbface_to_lbgface: subface to local background face\nbface_to_bgcell: subface to background cell\nbface_to_io: subface to IN/OUT\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.Tetrahedron","page":"Private types","title":"STLCutters.Tetrahedron","text":"struct Tetrahedron{D,T}<:Face{3,D}\n\n3-dimensional simplex Face defined by four points.\n\n\n\n\n\n","category":"type"},{"location":"types/#STLCutters.Triangle","page":"Private types","title":"STLCutters.Triangle","text":"struct Triangle{D,T}<:Face{2,D}\n\n2-dimensional simplex Face defined by three points.\n\n\n\n\n\n","category":"type"}]
}
